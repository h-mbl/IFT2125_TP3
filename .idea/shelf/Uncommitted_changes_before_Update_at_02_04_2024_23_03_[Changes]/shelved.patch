Index: Q2 Escalade/ClimbingDifficultyCalculator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Nom, Matricule\r\n// Nom, Matricule\r\n\r\n#include \"ClimbingDifficultyCalculator.h\"\r\n#include <fstream>\r\n#include <vector>\r\n// #include <unordered_set>\r\n// #include <math.h>\r\n#include <iostream>\r\n#include <algorithm>\r\n\r\n//add\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\n// ce fichier contient les definitions des methodes de la classe ClimbingDifficultyCalculator\r\n// this file contains the definitions of the methods of the ClimbingDifficultyCalculator class\r\n\r\nClimbingDifficultyCalculator::ClimbingDifficultyCalculator()\r\n{\r\n}\r\n\r\nint ClimbingDifficultyCalculator::CalculateClimbingDifficulty(std::string filename)\r\n{\r\n    ifstream monFichier(\"./wall1.txt\");\r\n\r\n    if(monFichier.is_open())\r\n    {\r\n        string ligne;\r\n        while(getline(monFichier, ligne))\r\n        {\r\n            cout << ligne << endl;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"Impossible d'ouvrir le fichier\" << endl;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Q2 Escalade/ClimbingDifficultyCalculator.cpp b/Q2 Escalade/ClimbingDifficultyCalculator.cpp
--- a/Q2 Escalade/ClimbingDifficultyCalculator.cpp	(revision 6e341068667d7db9f14a40277a8a57246adae47a)
+++ b/Q2 Escalade/ClimbingDifficultyCalculator.cpp	(date 1712110779949)
@@ -1,17 +1,18 @@
-// Nom, Matricule
-// Nom, Matricule
+// Qiwu Wen, 20230961
+// herve ngisse,20204609
 
 #include "ClimbingDifficultyCalculator.h"
 #include <fstream>
 #include <vector>
 // #include <unordered_set>
-// #include <math.h>
+#include <math.h>
 #include <iostream>
 #include <algorithm>
 
 //add
 #include <sstream>
 
+
 using namespace std;
 
 // ce fichier contient les definitions des methodes de la classe ClimbingDifficultyCalculator
@@ -21,21 +22,97 @@
 {
 }
 
+vector<int> splitStringToInts(const string& input) {
+    istringstream stream(input);
+    vector<int> result;
+    string temp;
+    
+    while (getline(stream, temp, ',')) {
+        result.push_back(stoi(temp));
+    }
+
+    return result;
+}
+
+int rightLeft(const std::vector<std::vector<int>>& dp, int i, int j,vector<vector<int>> wall) {
+    int current = dp[i][j];
+    int n = dp[0].size();
+    int minVal = current; 
+
+    if (j + 1 < n) {
+        minVal = min(minVal, dp[i][j + 1] + wall[i][j]);
+    }
+
+    if (j - 1 >= 0) {
+        minVal = min(minVal, dp[i][j - 1] + wall[i][j]);
+    }
+
+    return minVal;
+}
+
 int ClimbingDifficultyCalculator::CalculateClimbingDifficulty(std::string filename)
 {
     ifstream monFichier("./wall1.txt");
-
-    if(monFichier.is_open())
-    {
-        string ligne;
+    vector<vector<int>> wall;
+    string ligne;
+
+    if(monFichier.is_open())
+    {
+        
         while(getline(monFichier, ligne))
         {
+            vector<int> colonne = splitStringToInts(ligne);
+            wall.push_back(colonne);
             cout << ligne << endl;
         }
+        monFichier.close();
+    }
+    else {
+        cout << "impossible d'ouvrir le ficher" << endl;
+        return -1; // Return -1 pour erreur
     }
-    else
-    {
-        cout << "Impossible d'ouvrir le fichier" << endl;
+
+    int m = wall.size();
+    int n = wall[0].size();
+    
+    vector<vector<int>> dp(m, vector<int>(n));
+
+    // Initialize the base row
+    for (int j = 0; j < n; ++j) {
+        dp[m-1][j] = wall[m-1][j];
     }
+
+    
+    
+    int MAX = pow(2,25);
+    
+    
+    //cout << ss << endl;
+
+    // Fill the dp table
+    for (int i = m - 2; i >= 0; --i) {
+
+        for (int j = 0; j < n; ++j) {
+            dp[i][j] = wall[i][j] + dp[i + 1][j]; 
+        }
+
+       
+    for (int k = 0; k < n - 1; ++k) { // il y a au maximum n-1 changement horizontal
+        for (int j = 0; j < n; ++j) {
+            
+            dp[i][j] = rightLeft(dp, i, j, wall); //fait echanger horizontalement
+        }
+    }
+    }
+
+    
+   
+    
+
+    // Find the minimum difficulty path from the top row
+
+    
+    cout << "resultat est "<<*min_element(dp[0].begin(), dp[0].end()) << endl;
+    return *min_element(dp[0].begin(), dp[0].end());
 }
 
Index: Q3 Vitre/vitre.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#Nom, matricule\r\n#Nom, matricule\r\nimport sys\r\n#Fonction à compléter. Ne modifiez pas sa signature.\r\n#N : Force maximale\r\n#k : Nombre de fenêtres disponibles\r\n#Valeur de retour : le nombre minimal de tests qu'il faut faire \r\n#                   en pire cas pour déterminer le seuil de solidité \r\n#                   d'une fenêtre\r\n#Doit retourner la réponse comme un int.\r\n#\r\n#Function to complete. Do not change its signature.\r\n#N : Maximum force\r\n#k : Number of windows available\r\n#return value : Minimum number of tests needed in the worst case\r\n#               to find the solidity threshold of a window\r\n#Must return the answer as an int. \r\ndef calcul_value(start, end, k, table):\r\n    if k == 1:\r\n        return end - start   # cas de base\r\n    if start >= end:\r\n        return 0 #valeur invalide\r\n    if table[start][end][k] != 0:  # memorisation\r\n        return table[start][end][k]\r\n\r\n    min_val = 999999999 # valeur minimale\r\n\r\n    for i in range(start, end + 1):  #i est la position courante\r\n\r\n        # nombre de lance maximal entre deux parties(vitre casse ou vitre non casse) dans le pire cas\r\n        cost = 1 + max(calcul_value(start, i-1, k, table), calcul_value(i, end, k-1, table))\r\n        # cout minimale\r\n        min_val = min(min_val, cost)\r\n\r\n    table[start][end][k] = min_val  # Memoize the result\r\n    print(start,end,k)\r\n    return min_val\r\n\r\ndef vitre(N, k):\r\n    tab = [[[0] * (k + 1) for _ in range(N + 1)]for _ in range(N+1)]\r\n\r\n\r\n    tab[1][N][k] = calcul_value(1,N,k,tab) # on n'a pas besoin de calculer tous les elements du tab,\r\n                                                # il faut juste calculer les donnees(sous-questions) besoins\r\n    print(tab[1][N])\r\n    return tab[1][N][k]\r\n\r\n\r\n#Fonction main, vous ne devriez pas avoir à modifier\r\n#Main function, you shouldn't have to modify it\r\ndef main(args):\r\n    N = int(args[0])\r\n    k = int(args[1])\r\n\r\n    answer = vitre(N,k)\r\n    print(answer)\r\n\r\nif __name__ == '__main__':\r\n    main(sys.argv[1:])
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Q3 Vitre/vitre.py b/Q3 Vitre/vitre.py
--- a/Q3 Vitre/vitre.py	(revision 6e341068667d7db9f14a40277a8a57246adae47a)
+++ b/Q3 Vitre/vitre.py	(date 1712110779957)
@@ -1,5 +1,5 @@
-#Nom, matricule
-#Nom, matricule
+# Qiwu Wen, 20230961
+# herve ngisse,20204609
 import sys
 #Fonction à compléter. Ne modifiez pas sa signature.
 #N : Force maximale
@@ -33,7 +33,7 @@
         min_val = min(min_val, cost)
 
     table[start][end][k] = min_val  # Memoize the result
-    print(start,end,k)
+
     return min_val
 
 def vitre(N, k):
@@ -42,7 +42,7 @@
 
     tab[1][N][k] = calcul_value(1,N,k,tab) # on n'a pas besoin de calculer tous les elements du tab,
                                                 # il faut juste calculer les donnees(sous-questions) besoins
-    print(tab[1][N])
+
     return tab[1][N][k]
 
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"418bacef-eeab-41fb-99ad-f7f2ac7abd0d\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/IFT2125_TP3.iml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/IFT2125_TP3.iml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/Q2 Escalade/cmake-build-debug/Testing/Temporary/LastTest.log\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Q2 Escalade/cmake-build-debug/Testing/Temporary/LastTest.log\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test2.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test2.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;h-mbl&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GitHubPullRequestState\">{\r\n  &quot;prStates&quot;: []\r\n}</component>\r\n  <component name=\"GitLabMergeRequestsSettings\">{}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/h-mbl/IFT2125_TP3.git&quot;,\r\n    &quot;accountId&quot;: &quot;b1787650-1eff-4ae8-8a3c-930d26ff3055&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 3\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2eEKeCMuTRwSWidhffd153LAXn7\" />\r\n  <component name=\"ProjectLevelVcsManager\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python.labyrinth_generator_creator.executor\": \"Debug\",\r\n    \"Python.q2.executor\": \"Run\",\r\n    \"Python.test.executor\": \"Run\",\r\n    \"Python.test1.executor\": \"Run\",\r\n    \"Python.test2.executor\": \"Run\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"last_opened_file_path\": \"C:/Users/herve/OneDrive/Documents/GitHub/IFT2125_TP3/Q4 Labyrinthe/labyrinth_generator_creator.py\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"settings.editor.selected.configurable\": \"com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"labyrinth_generator_creator\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\r\n      <module name=\"IFT2125_TP3\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"SDK_NAME\" value=\"Python 3.11\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/Q4 Labyrinthe/labyrinth_generator_creator.py\" />\r\n      <option name=\"PARAMETERS\" value=\"2\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-1d06a55b98c1-74d2a5396914-JavaScript-PY-241.14494.200\" />\r\n        <option value=\"bundled-python-sdk-86178adc3299-28c9f5db9ffe-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-241.14494.200\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"418bacef-eeab-41fb-99ad-f7f2ac7abd0d\" name=\"Changes\" comment=\"\" />\r\n      <created>1711464390863</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1711464390863</updated>\r\n      <workItem from=\"1711464391794\" duration=\"9616000\" />\r\n      <workItem from=\"1711485402330\" duration=\"15756000\" />\r\n      <workItem from=\"1711544455445\" duration=\"5510000\" />\r\n      <workItem from=\"1711631505912\" duration=\"4738000\" />\r\n      <workItem from=\"1711676877901\" duration=\"45000\" />\r\n      <workItem from=\"1711741284411\" duration=\"16647000\" />\r\n      <workItem from=\"1712033453654\" duration=\"6473000\" />\r\n      <workItem from=\"1712075791282\" duration=\"1564000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <watches-manager>\r\n      <configuration name=\"PythonConfigurationType\">\r\n        <watch expression=\"tmp_position\" />\r\n        <watch expression=\"element\" />\r\n      </configuration>\r\n    </watches-manager>\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/IFT2125_TP3$test.coverage\" NAME=\"test Coverage Results\" MODIFIED=\"1711843967031\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/labyrinth_generator_creator_py$labyrinth_generator_creator.coverage\" NAME=\"labyrinth_generator_creator Coverage Results\" MODIFIED=\"1712033485825\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"\" />\r\n    <SUITE FILE_PATH=\"coverage/IFT2125_TP3$test1.coverage\" NAME=\"test1 Coverage Results\" MODIFIED=\"1711843977781\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/IFT2125_TP3$q2.coverage\" NAME=\"q2 Coverage Results\" MODIFIED=\"1711645394360\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/IFT2125_TP3$test2.coverage\" NAME=\"test2 Coverage Results\" MODIFIED=\"1711932358468\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/labyrinth_generator_creator_py$test.coverage\" NAME=\"test Coverage Results\" MODIFIED=\"1712076985178\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/IFT2125_TP3$maze.coverage\" NAME=\"maze Coverage Results\" MODIFIED=\"1711904262411\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Q4 Labyrinthe\" />\r\n    <SUITE FILE_PATH=\"coverage/labyrinth_generator_creator_py$test2.coverage\" NAME=\"test2 Coverage Results\" MODIFIED=\"1712077363490\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/IFT2125_TP3$labyrinth_generator_creator.coverage\" NAME=\"labyrinth_generator_creator Coverage Results\" MODIFIED=\"1711937263176\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/Q4 Labyrinthe\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 6e341068667d7db9f14a40277a8a57246adae47a)
+++ b/.idea/workspace.xml	(date 1712113352687)
@@ -5,11 +5,11 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="418bacef-eeab-41fb-99ad-f7f2ac7abd0d" name="Changes" comment="">
-      <change beforePath="$PROJECT_DIR$/.idea/IFT2125_TP3.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/IFT2125_TP3.iml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/Q4 Labyrinthe/Q4.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/q1.pdf" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/Q2 Escalade/cmake-build-debug/Testing/Temporary/LastTest.log" beforeDir="false" afterPath="$PROJECT_DIR$/Q2 Escalade/cmake-build-debug/Testing/Temporary/LastTest.log" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test.py" beforeDir="false" afterPath="$PROJECT_DIR$/test.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test2.py" beforeDir="false" afterPath="$PROJECT_DIR$/test2.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Q2 Escalade/ClimbingDifficultyCalculator.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Q2 Escalade/ClimbingDifficultyCalculator.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Q3 Vitre/vitre.py" beforeDir="false" afterPath="$PROJECT_DIR$/Q3 Vitre/vitre.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -53,26 +53,26 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Python.labyrinth_generator_creator.executor": "Debug",
-    "Python.q2.executor": "Run",
-    "Python.test.executor": "Run",
-    "Python.test1.executor": "Run",
-    "Python.test2.executor": "Run",
-    "RunOnceActivity.OpenProjectViewOnStart": "true",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "main",
-    "last_opened_file_path": "C:/Users/herve/OneDrive/Documents/GitHub/IFT2125_TP3/Q4 Labyrinthe/labyrinth_generator_creator.py",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)",
-    "nodejs_package_manager_path": "npm",
-    "settings.editor.selected.configurable": "com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable",
-    "vue.rearranger.settings.migration": "true"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Python.labyrinth_generator_creator.executor&quot;: &quot;Debug&quot;,
+    &quot;Python.q2.executor&quot;: &quot;Run&quot;,
+    &quot;Python.test.executor&quot;: &quot;Run&quot;,
+    &quot;Python.test1.executor&quot;: &quot;Run&quot;,
+    &quot;Python.test2.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;Merging main&quot;,
+    &quot;last_opened_file_path&quot;: &quot;C:/Users/herve/OneDrive/Documents/GitHub/IFT2125_TP3/Q4 Labyrinthe/labyrinth_generator_creator.py&quot;,
+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;,
+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
   }
-}]]></component>
+}</component>
   <component name="RunManager">
     <configuration name="labyrinth_generator_creator" type="PythonConfigurationType" factoryName="Python" nameIsGenerated="true">
       <module name="IFT2125_TP3" />
@@ -150,13 +150,15 @@
   </component>
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
     <SUITE FILE_PATH="coverage/IFT2125_TP3$test.coverage" NAME="test Coverage Results" MODIFIED="1711843967031" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$labyrinth_generator_creator.coverage" NAME="labyrinth_generator_creator Coverage Results" MODIFIED="1712033485825" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="" />
+    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$labyrinth_generator_creator.coverage" NAME="labyrinth_generator_creator Coverage Results" MODIFIED="1712110576455" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="" />
     <SUITE FILE_PATH="coverage/IFT2125_TP3$test1.coverage" NAME="test1 Coverage Results" MODIFIED="1711843977781" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$testdjiskra.coverage" NAME="testdjiskra Coverage Results" MODIFIED="1712086258249" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/IFT2125_TP3$q2.coverage" NAME="q2 Coverage Results" MODIFIED="1711645394360" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/IFT2125_TP3$test2.coverage" NAME="test2 Coverage Results" MODIFIED="1711932358468" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$test.coverage" NAME="test Coverage Results" MODIFIED="1712076985178" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$test.coverage" NAME="test Coverage Results" MODIFIED="1712077379363" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/IFT2125_TP3$maze.coverage" NAME="maze Coverage Results" MODIFIED="1711904262411" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Q4 Labyrinthe" />
-    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$test2.coverage" NAME="test2 Coverage Results" MODIFIED="1712077363490" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$test2.coverage" NAME="test2 Coverage Results" MODIFIED="1712086282202" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/labyrinth_generator_creator_py$algorithm1.coverage" NAME="algorithm1 Coverage Results" MODIFIED="1712099350452" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Q4 Labyrinthe" />
     <SUITE FILE_PATH="coverage/IFT2125_TP3$labyrinth_generator_creator.coverage" NAME="labyrinth_generator_creator Coverage Results" MODIFIED="1711937263176" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/Q4 Labyrinthe" />
   </component>
 </project>
\ No newline at end of file
Index: Q4 Labyrinthe/Q4.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Q4 Labyrinthe/Q4.py b/Q4 Labyrinthe/Q4.py
new file mode 100644
--- /dev/null	(date 1712110889389)
+++ b/Q4 Labyrinthe/Q4.py	(date 1712110889389)
@@ -0,0 +1,487 @@
+import sys
+import random
+
+
+cell_size = 10 #mm
+wall_height = 10 #mm
+wall_thickness = 1 #mm
+
+strategy_choice = 1
+
+class Strategy :
+    def __init__(self):
+        pass
+
+    def Apply(self):
+        print("Applying Abstract Strategy")
+
+    def DoSomething(self):
+        algo1 = Algorithm1()
+        maze = algo1.initialisation()
+
+        print("Do Something")
+
+class Algorithm1(Strategy) :
+    #widson's algorithm
+    width = 13
+    height = 13
+    def adjacentCells(self,pos:(int,int)):
+        directions = [(0,1),(1,0),(0,-1),(-1,0)]
+        cellAdjacents = []
+
+        x = pos[0]
+        y = pos[1]
+        for direction in directions:
+            X = direction[0] + x
+            Y = direction[1] + y
+            if(X >= 0 and X < self.width  and
+                    (Y >= 0 and Y < self.height)):
+                cellAdjacents.append((X, Y))
+        return cellAdjacents
+
+    def getchemin(self, visited, start : (int,int)):
+        chemin = [start]
+        curr = start
+
+        while True:
+            adjacent = self.adjacentCells(curr)
+            choix= random.choice(adjacent)
+
+            if all(pos in chemin for pos in adjacent): # si on est dans un boucle infini, on recommence
+                curr = start
+                chemin = [start]
+            elif choix in chemin: #si chemin loop, on refait le random
+                continue
+
+            elif choix in visited:
+                chemin.append(choix)
+                return chemin #condition fin
+
+            elif choix not in visited:
+                curr = choix
+                chemin.append(choix) #on ajoute le randomWalk au chemin
+
+
+
+    def initialisation(self):
+
+        visited = set() #set des positions deja passes
+        unvisited = []
+        for w in range(self.width): #initialisation
+            for h in range(self.height):
+                pair = (w,h)
+                unvisited.append(pair)
+
+        start = (0,0)
+        visited.add(start)
+        result = []
+        unvisited.remove(start)
+
+        while len(unvisited) != 0 :
+
+
+           # choix = random.choice(unvisited)
+           # if(choix == start) : continue
+            choix = random.choice(unvisited)
+            chemin = self.getchemin(visited,choix)
+            copy = chemin.copy()
+            result.append(copy)
+            chemin.pop()
+            for pos in chemin:
+                visited.add(pos)
+                if pos in unvisited: unvisited.remove(pos)
+
+
+
+
+        #le resultat est une liste des chemins passes qui combinent le labyrinth
+        print(len(result))
+        breakpoint()
+        m = self.chemins2murs(result)
+        print(len(m))
+        breakpoint()
+
+        code = self.translateMap2SCAD(m)
+        print(code)
+        return m
+
+    def chemins2murs(self,chemins):
+        m = dict()
+        for chemin in chemins:
+            last = chemin[0]
+
+
+            for i in range(1,len(chemin)):
+
+                curr = chemin[i]
+
+                m[(last,curr)] = 0
+                last = curr
+            cases = []
+        for x in range(self.width):
+            for y in range(self.width):
+                cases.append((x,y))
+        for pos in cases:
+            adjacent = self.adjacentCells(pos)
+            for pos2 in adjacent:
+                if (pos2,pos) not in m:
+                    if (pos, pos2) not in m:
+
+                        m[(pos,pos2)] = 1
+        return m
+
+    def rotationOrNot(self,p1,p2):
+        x = abs(p1[0] - p2[0])
+        y = abs(p1[1] - p2[1])
+        if (x,y) == (1,0): return False
+        elif (x,y) == (0,1): return True
+
+    def translateMap2SCAD(self,m):
+        #initialisation
+
+        result = "" #codeSCAD
+
+        result += "translate([-0.5,-0.5,-1]) cube(["+ str(self.height * cell_size +1)+',' + str(self.width * cell_size + 1)+ ", 1]); \n"
+        # base
+        milieu_width = self.width * cell_size/2
+        milieu_height = self.height * cell_size/2
+        # les 4 grand murs
+        result += "translate([0, %f, %f]){rotate([0,0,90]){cube([%f,1,%f], center = true);}} \n" %(milieu_height+ cell_size/2, cell_size/2 ,  self.height * cell_size +1 - cell_size,wall_height)
+        result += "translate([%f, %f, %f]){rotate([0,0,90]){cube([%f,1,%f], center = true);}} \n" % (cell_size*self.height,milieu_height, cell_size / 2, self.height * cell_size + 1, wall_height)
+        result += "translate([%f, 0, %f]){cube([%f,1,%f], center = true);} \n" % (milieu_width, cell_size / 2, self.height * cell_size + 1, wall_height)
+        result += "translate([%f, %f, %f]){cube([%f,1,%f], center = true);} \n" % (milieu_width, cell_size * self.width,cell_size/2, self.height * cell_size + 1, wall_height)
+
+        cases = []
+        for x in range(self.width):
+            for y in range(self.height):
+                cases.append((x,y))
+
+        for p1 in cases:
+            adjacent = self.adjacentCells(p1)
+            for p2 in adjacent:
+
+
+                if (p1,p2) in m:
+                    if m[(p1,p2)] == 1:
+                        result += self.murGeneration(p1,p2)
+
+
+
+                elif (p2,p1) in m:
+                    if m[(p2,p1)] == 1:
+                        result += self.murGeneration(p1,p2)
+
+
+        return result
+
+
+
+
+
+    def murGeneration(self,p1,p2):
+
+        rotation = self.rotationOrNot(p1, p2)
+        rotation = rotation * 90
+
+        if rotation != 0:
+            result = "translate([%f, %f, %f]){rotate([0,0,%f]){cube([%f,1,%f], center = true);} } \n" % (
+                (max(p1[1],p2[1]))*cell_size, p1[0] * cell_size+ cell_size/2, wall_height / 2, rotation, cell_size + wall_thickness, wall_height)
+        else:
+            result = "translate([%f, %f, %f]){rotate([0,0,%f]){cube([%f,1,%f], center = true);} } \n" % (
+                p1[1] * cell_size + cell_size/2, max(p1[0],p2[0]) * cell_size , wall_height / 2, rotation,
+                cell_size + wall_thickness, wall_height)
+
+        return result
+
+
+    def Apply(self):
+        #super().Apply()
+        print("Applying Algorithm1")
+
+class Algorithm2(Strategy) :
+    def __init__(self):
+        super().__init__()
+        # Définition de la longueur et la hauteur du labyrinthe
+        self.width = 13
+        self.height = 13
+        # Initialisation de la grille avec des murs (représentés par 1) et des cases non visitées
+        self.grid = [[1 for _ in range(self.width)] for _ in range(self.height)]
+        # Initialisation de la matrice des cases visitées
+        self.visited = [[False for _ in range(self.width)] for _ in range(self.height)]
+        # Initialisation du chemin avec le point de départ (0,0)
+        self.chemin = [(0, 0)]
+        self.stack = [(0, 0)]
+    #""""
+
+    def backtracker(self, x, y):
+        # ici,on cherhce les elements non-visites de notre element actuel
+        while True:
+            neighbors = self.get_unvisited_neighbors(x, y)
+            # si la liste est vide, ce qu'on a visite tous les elements proches
+            if not neighbors:
+                chemins = self.chercherbranche()
+                m = self.chemins2murs(chemins)
+                self.translateMap2SCAD(m)
+                return 0
+
+            # on choisit aleatoirement  l'element qui sera place comme visite dans la liste des voisns
+            nx, ny = random.choice(neighbors)
+            # on supprimer le mur
+            self.remove_wall(x, y, nx, ny)
+            self.visited[ny][nx] = True
+            # on fait une reccursion
+            self.chemin.append((nx,ny))
+            self.backtracker(nx, ny)
+
+    def branche_backtracker(self, x, y):
+        # ici,on cherhce les elements non-visites de notre element actuel
+        while True:
+            neighbors = self.get_unvisited_neighbors(x, y)
+            # si la liste est vide, ce qu'on a visite tous les elements proches
+            if not neighbors:
+                return self.tmp_chemin
+            # on choisit aleatoirement  l'element qui sera place comme visite dans la liste des voisns
+            nx, ny = random.choice(neighbors)
+            # on supprimer le mur
+            self.remove_wall(x, y, nx, ny)
+            self.visited[ny][nx] = True
+            # on fait une reccursion
+            self.tmp_chemin.append((nx, ny))
+            self.branche_backtracker(nx, ny)
+
+    def chercherbranche(self):
+        chemin_principal =[]
+
+        #print(self.visited)
+        for element in self.chemin :
+            x,y = element
+            self.tmp_chemin = [(x, y)]
+            self.branche_backtracker(x,y)
+
+            chemin_principal.append(self.tmp_chemin)
+
+
+        unvisited = []
+        for w in range(self.width):  # initialisation
+            for h in range(self.height):
+                pair = (w, h)
+                unvisited.append(pair)
+        while len(unvisited) > 0:
+
+            flattened_list = [item for sublist in chemin_principal for item in sublist]
+            for element in unvisited:
+                if element in flattened_list:
+                    unvisited.remove(element)
+            for element in unvisited:
+                x,y = element
+                self.visited[y][x] = True
+                self.tmp_chemin = [(x, y)]
+                self.branche_backtracker(x, y)
+                chemin_principal.append(self.tmp_chemin)
+
+        connexion =[]
+        for element in chemin_principal:
+            if len(element) == 1:
+                connexion.append(element)
+                chemin_principal.remove(element)
+        flattened_list = [item for sublist in connexion for item in sublist]
+        ok = []
+        for element in flattened_list :
+            x,y = element
+            tmp_chemin = [(x, y)]
+
+            liste_adj = self.adjacentCells((x,y))
+            for element in liste_adj :
+                if element in connexion and element not in ok :
+                    nx,ny = element
+                    tmp_chemin.append((nx,ny))
+                    ok.append((nx,ny))
+            if len(tmp_chemin) > 0:
+                chemin_principal.append(tmp_chemin)
+
+        return chemin_principal
+
+    def get_unvisited_neighbors(self, x, y):
+        # enregistre les elements visites
+        neighbors = []
+        # droite, gauche, haut, bas
+        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
+            nx, ny = x + dx, y + dy
+            # si l'element n'est pas visite et tous les autres cas, on ajoute l'elements a la liste des voisins
+            if 0 <= nx < self.width and 0 <= ny < self.height and not self.visited[ny][nx]:
+                neighbors.append((nx, ny))
+        # retourne la liste
+        return neighbors
+
+    def remove_wall(self, x, y, nx, ny):
+        # Si les cellules sont horizontalement adjacentes (x == nx),
+        # cela signifie qu'il y a un mur horizontal entre elles.
+        # Dans ce cas, la fonction met à 0 (supprime le mur) dans la grille aux positions [y][x] et [ny][nx].
+        # Cela crée un passage horizontal entre les deux cellules.
+        if x == nx:
+            self.grid[y][x] = 0
+            self.grid[ny][nx] = 0
+        # Si les cellules sont verticalement adjacentes (x != nx), cela signifie qu'il y a un mur vertical entre elles.
+        # Dans ce cas, la fonction met à 0 (supprime le mur) dans la grille aux positions [y][x] et [y][nx].
+        # Cela crée un passage vertical entre les deux cellules.
+        else:
+            self.grid[y][x] = 0
+            self.grid[y][nx] = 0
+
+    def Apply(self):
+        print("Applying Algorithm2")
+        # Forcer la première ligne (y = 0)
+        a = 0
+        start_y  = 0
+        # Choisir une colonne aléatoire, apparement il doit aussi commencer par 0
+        start_x = 0
+        # on change l'element comme True dans le tableau visited
+        self.visited[start_y][start_x] = True
+        # on appelle la fonction backtracker avec les starts elements
+        self.backtracker(start_x, start_y)
+       # self.translateMap2SCAD('maze.scad', self.width, self.height)
+    def adjacentCells(self,pos:(int,int)):
+        directions = [(0,1),(1,0),(0,-1),(-1,0)]
+        cellAdjacents = []
+
+        x = pos[0]
+        y = pos[1]
+        for direction in directions:
+            X = direction[0] + x
+            Y = direction[1] + y
+            if (X >= 0 and X < self.width  and
+                    (Y >= 0 and Y < self.height)):
+                cellAdjacents.append((X, Y))
+        return cellAdjacents
+    def chemins2murs(self, chemins):
+        m = dict()
+        for chemin in chemins:
+            last = chemin[0]
+
+            for i in range(1, len(chemin)):
+                curr = chemin[i]
+
+                m[(last, curr)] = 0
+                last = curr
+            cases = []
+        for x in range(self.width):
+            for y in range(self.width):
+                cases.append((x, y))
+        for pos in cases:
+            adjacent = self.adjacentCells(pos)
+            for pos2 in adjacent:
+                if (pos2, pos) not in m:
+                    if (pos, pos2) not in m:
+                        m[(pos, pos2)] = 1
+        return m
+
+    def translateMap2SCAD(self,m):
+        #initialisation
+
+        result = "" #codeSCAD
+
+        result += "translate([-0.5,-0.5,-1]) cube(["+ str(self.height * cell_size +1)+',' + str(self.width * cell_size + 1)+ ", 1]); \n"
+        # base
+        milieu_width = self.width * cell_size/2
+        milieu_height = self.height * cell_size/2
+        # les 4 grand murs
+        result += "translate([0, %f, %f]){rotate([0,0,90]){cube([%f,1,%f], center = true);}} \n" %(milieu_height+ cell_size/2, cell_size/2 ,  self.height * cell_size +1 - cell_size,wall_height)
+        result += "translate([%f, %f, %f]){rotate([0,0,90]){cube([%f,1,%f], center = true);}} \n" % (cell_size*self.height,milieu_height, cell_size / 2, self.height * cell_size + 1, wall_height)
+        result += "translate([%f, 0, %f]){cube([%f,1,%f], center = true);} \n" % (milieu_width, cell_size / 2, self.height * cell_size + 1, wall_height)
+        result += "translate([%f, %f, %f]){cube([%f,1,%f], center = true);} \n" % (milieu_width, cell_size * self.width,cell_size/2, self.height * cell_size + 1, wall_height)
+
+        cases = []
+        for x in range(self.width):
+            for y in range(self.height):
+                cases.append((x,y))
+
+        for p1 in cases:
+            adjacent = self.adjacentCells(p1)
+            for p2 in adjacent:
+
+
+                if (p1,p2) in m:
+                    if m[(p1,p2)] == 1:
+                        result += self.murGeneration(p1,p2)
+
+
+
+                elif (p2,p1) in m:
+                    if m[(p2,p1)] == 1:
+                        result += self.murGeneration(p1,p2)
+
+
+        print(result)
+        return result
+
+    def rotationOrNot(self, p1, p2):
+        x = abs(p1[0] - p2[0])
+        y = abs(p1[1] - p2[1])
+        if (x, y) == (1, 0):
+            return False
+        elif (x, y) == (0, 1):
+            return True
+
+
+    def murGeneration(self,p1,p2):
+
+        rotation = self.rotationOrNot(p1, p2)
+        rotation = rotation * 90
+
+        if rotation != 0:
+            result = "translate([%f, %f, %f]){rotate([0,0,%f]){cube([%f,1,%f], center = true);} } \n" % (
+                (max(p1[1],p2[1]))*cell_size, p1[0] * cell_size+ cell_size/2, wall_height / 2, rotation, cell_size + wall_thickness, wall_height)
+        else:
+            result = "translate([%f, %f, %f]){rotate([0,0,%f]){cube([%f,1,%f], center = true);} } \n" % (
+                p1[1] * cell_size + cell_size/2, max(p1[0],p2[0]) * cell_size , wall_height / 2, rotation,
+                cell_size + wall_thickness, wall_height)
+
+        return result
+
+
+class Generator() :
+    strategy = None
+
+    def __init__(self):
+        pass
+
+    def SetStrategy(self, new_strategy):
+        self.strategy = new_strategy
+
+    def Generate(self):
+        self.strategy.Apply()
+        self.strategy.DoSomething()
+
+class Creator() :
+    def __init__(self):
+        pass
+
+    def PrintLabyrinth(self):
+        pass
+
+
+# main call
+def main():
+    global strategy_choice
+    args = sys.argv[:]
+    if len(args) >= 2 :
+        strategy_choice = int(args[1])
+
+    # Generator
+    my_generator = Generator()
+    if strategy_choice == 1:
+        my_generator.SetStrategy(Algorithm1())
+    elif strategy_choice == 2:
+        my_generator.SetStrategy(Algorithm2())
+    else :
+        print("error strategy choice")
+    my_generator.Generate()
+
+    #Creator
+    my_creator = Creator()
+    my_creator.PrintLabyrinth()
+
+
+if __name__ == "__main__":
+    main()
+
